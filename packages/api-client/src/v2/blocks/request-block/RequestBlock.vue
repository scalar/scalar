<script setup lang="ts">
import { ScalarErrorBoundary } from '@scalar/components'
import { canMethodHaveBody } from '@scalar/helpers/http/can-method-have-body'
import type { HttpMethod } from '@scalar/helpers/http/http-methods'
import { REGEX } from '@scalar/helpers/regex/regex-helpers'
import type { WorkspaceStore } from '@scalar/workspace-store/client'
import type { SelectedSecurity } from '@scalar/workspace-store/entities/auth'
import type {
  ApiReferenceEvents,
  AuthMeta,
  WorkspaceEventBus,
} from '@scalar/workspace-store/events'
import { getResolvedRef } from '@scalar/workspace-store/helpers/get-resolved-ref'
import { unpackProxyObject } from '@scalar/workspace-store/helpers/unpack-proxy'
import type { XScalarEnvironment } from '@scalar/workspace-store/schemas/extensions/document/x-scalar-environments'
import type { XScalarCookie } from '@scalar/workspace-store/schemas/extensions/general/x-scalar-cookies'
import type {
  OpenApiDocument,
  OperationObject,
  ServerObject,
} from '@scalar/workspace-store/schemas/v3.1/strict/openapi-document'
import { computed, ref, useId, watch } from 'vue'

import SectionFilter from '@/components/SectionFilter.vue'
import ViewLayoutSection from '@/components/ViewLayout/ViewLayoutSection.vue'
import type { ClientLayout } from '@/hooks'
import { filterGlobalCookie } from '@/v2/blocks/operation-block/helpers/filter-global-cookies'
import { getExample } from '@/v2/blocks/operation-block/helpers/get-example'
import { getResolvedUrl } from '@/v2/blocks/operation-block/helpers/get-resolved-url'
import type { ClientOptionGroup } from '@/v2/blocks/operation-code-sample'
import RequestBody from '@/v2/blocks/request-block/components/RequestBody.vue'
import RequestCodeSnippet from '@/v2/blocks/request-block/components/RequestCodeSnippet.vue'
import RequestParams from '@/v2/blocks/request-block/components/RequestParams.vue'
import type { TableRow } from '@/v2/blocks/request-block/components/RequestTableRow.vue'
import { createParameterHandlers } from '@/v2/blocks/request-block/helpers/create-parameter-handlers'
import { getDefaultHeaders } from '@/v2/blocks/request-block/helpers/get-default-headers'
import { getParameterSchema } from '@/v2/blocks/request-block/helpers/get-parameter-schema'
import { groupBy } from '@/v2/blocks/request-block/helpers/group-by'
import { isParamDisabled } from '@/v2/blocks/request-block/helpers/is-param-disabled'
import {
  AuthSelector,
  type MergedSecuritySchemes,
} from '@/v2/blocks/scalar-auth-selector-block'
import type { SecuritySchemeObjectSecret } from '@/v2/blocks/scalar-auth-selector-block/helpers/secret-types'
import type { ClientPlugin } from '@/v2/helpers/plugins'

type Filter =
  | 'All'
  | 'Auth'
  | 'Variables'
  | 'Cookies'
  | 'Headers'
  | 'Query'
  | 'Body'

export type ExtendedScalarCookie = XScalarCookie & {
  location: 'document' | 'workspace'
}

const {
  authMeta = { type: 'document' },
  clientOptions,
  environment,
  eventBus,
  exampleKey,
  globalCookies,
  layout,
  method,
  operation,
  path,
  plugins,
  proxyUrl,
  securityRequirements,
  securitySchemes,
  selectedClient,
  selectedSecuritySchemes,
  server,
} = defineProps<{
  authMeta: AuthMeta
  clientOptions: ClientOptionGroup[]
  environment: XScalarEnvironment
  eventBus: WorkspaceEventBus
  exampleKey: string
  globalCookies: ExtendedScalarCookie[]
  layout: ClientLayout
  method: HttpMethod
  operation: OperationObject
  path: string
  plugins: ClientPlugin[]
  proxyUrl: string
  securityRequirements: OpenApiDocument['security']
  securitySchemes: MergedSecuritySchemes
  selectedClient: WorkspaceStore['workspace']['x-scalar-default-client']
  selectedSecurity: SelectedSecurity
  selectedSecuritySchemes: SecuritySchemeObjectSecret[]
  server: ServerObject | null
}>()

/** Operation metadata used across event emissions */
const meta = computed(() => ({
  method,
  path,
  exampleKey,
}))

/** Parameters grouped by type (path, query, header, cookie) */
const sections = computed(() =>
  groupBy(
    operation.parameters?.map((param) => getResolvedRef(param)) ?? [],
    'in',
    (param) => {
      const example = getExample(param, exampleKey, undefined)

      return {
        name: param.name,
        value: example?.value ?? '',
        description: param.description,
        schema: getParameterSchema(param),
        isRequired: param.required,
        isDisabled: isParamDisabled(param, example),
        originalParameter: param,
      } as TableRow
    },
  ),
)

// Generate a reverse map for fast lookup of headers by the name
const headersMap = computed(() =>
  groupBy(
    sections.value.header?.map((it) => ({
      ...it,
      name: it.name.toLowerCase(),
    })) ?? [],
    'name',
  ),
)

const autoGeneratedHeaders = computed(() =>
  getDefaultHeaders({ method, operation, exampleKey }),
)

const defaultHeaders = computed(() => {
  const disableParameters =
    operation['x-scalar-disable-parameters']?.['default-headers']?.[
      exampleKey
    ] ?? {}

  return autoGeneratedHeaders.value.map((it) => {
    const realHeader = headersMap.value[it.name.toLowerCase()]?.[0]

    return {
      name: it.name,
      value: it.defaultValue,
      schema: undefined,
      isOverridden: realHeader && !realHeader?.isDisabled,
      isReadonly: true,
      isDisabled: disableParameters[it.name.toLowerCase()] ?? false,
    } satisfies TableRow
  })
})

const headers = computed(() => [
  ...defaultHeaders.value,
  ...(sections.value.header ?? []),
])

const defaultCookies = computed(() => {
  const resolvedUrl = getResolvedUrl({
    environment,
    server,
    path,
    pathVariables: {},
  })

  const disabledGlobalCookies =
    operation['x-scalar-disable-parameters']?.['global-cookies']?.[
      exampleKey
    ] ?? {}

  return (
    globalCookies
      ?.filter((cookie) =>
        filterGlobalCookie({
          cookie,
          url: resolvedUrl,
          // Do not filter global cookies for the default cookies section (it's already filtered in the buildRequestCookieHeader function)
          // This is because we still want to show them on the UI
          disabledGlobalCookies: {},
        }),
      )
      .map((it) => ({
        name: it.name,
        value: it.value,
        globalRoute:
          it.location === 'document' ? 'document.cookies' : 'workspace.cookies',
        isReadonly: true,
        isDisabled: disabledGlobalCookies[it.name.toLowerCase()] ?? false,
      })) ?? ([] satisfies TableRow[])
  )
})

const cookies = computed(() => [
  ...(defaultCookies.value ?? []),
  ...(sections.value.cookie ?? []),
])

/** Currently selected filter for the request sections */
const selectedFilter = ref<Filter>('All')

/** Available operation sections */
const OPERATION_SECTIONS: readonly Filter[] = [
  'Auth',
  'Variables',
  'Cookies',
  'Headers',
  'Query',
  'Body',
] as const

/**
 * Pre-generated stable IDs for all possible filter sections.
 * These are created once at setup time to avoid regenerating IDs on re-render.
 */
const sectionIds: Record<Filter, string> = {
  All: useId(),
  Auth: useId(),
  Variables: useId(),
  Cookies: useId(),
  Headers: useId(),
  Query: useId(),
  Body: useId(),
}

/** Filters available based on operation state */
const filters = computed<Filter[]>(() => {
  const availableFilters = new Set<Filter>(['All', ...OPERATION_SECTIONS])

  if (!sections.value.path?.length) {
    availableFilters.delete('Variables')
  }
  if (!canMethodHaveBody(method)) {
    availableFilters.delete('Body')
  }
  if (isAuthHidden.value) {
    availableFilters.delete('Auth')
  }

  return [...availableFilters]
})

/**
 * Map available filters to their pre-generated stable IDs.
 * Only includes IDs for filters that are currently available.
 */
const filterIds = computed(
  () =>
    Object.fromEntries(
      filters.value.map((section) => [section, sectionIds[section]]),
    ) as Record<Filter, string>,
)

/**
 * Hide auth selector in readonly mode when no security schemes are defined.
 * This keeps the UI clean when there are no authentication options available.
 */
const isAuthHidden = computed(
  () =>
    layout === 'modal' &&
    !operation.security &&
    !Object.keys(securitySchemes ?? {}).length,
)

/** Get a sensible placeholder for the request name input */
const requestNamePlaceholder = computed(() => {
  if (operation.summary) {
    return operation.summary
  }
  const cleanPath = path.replace(REGEX.PROTOCOL, '')
  return cleanPath || 'Request Name'
})

/** Check if the section should be shown based on the selected filter */
const isSectionVisible = (section: Filter): boolean => {
  return selectedFilter.value === 'All' || selectedFilter.value === section
}

/**
 * Reset filter to 'All' if Body filter is selected but method changes to one that cannot have a body.
 * This prevents showing an empty Body section when switching methods.
 */
watch(
  () => method,
  (newMethod) => {
    if (selectedFilter.value === 'Body' && !canMethodHaveBody(newMethod)) {
      selectedFilter.value = 'All'
    }
  },
)

/** Handle operation summary updates */
const handleSummaryUpdate = (event: Event): void => {
  const summary = (event.target as HTMLInputElement).value
  eventBus.emit('operation:update:summary', {
    meta: meta.value,
    payload: { summary },
  })
}

/** Parameter handlers */
const parameterHandlers = computed(() => ({
  path: createParameterHandlers('path', eventBus, meta.value, {
    context: sections.value.path ?? [],
  }),
  cookie: createParameterHandlers('cookie', eventBus, meta.value, {
    context: cookies.value ?? [],
    globalParameters: defaultCookies.value.length,
  }),
  header: createParameterHandlers('header', eventBus, meta.value, {
    context: headers.value,
    defaultParameters: defaultHeaders.value.length,
  }),
  query: createParameterHandlers('query', eventBus, meta.value, {
    context: sections.value.query ?? [],
  }),
}))

/** Handle request body content type update */
const handleUpdateContentType = (payload: { value: string }): void =>
  eventBus.emit('operation:update:requestBody:contentType', {
    payload: { contentType: payload.value },
    meta: meta.value,
  })

/** Handle request body value update */
const handleUpdateBodyValue = ({
  payload,
  contentType,
}: Pick<
  ApiReferenceEvents['operation:update:requestBody:value'],
  'payload' | 'contentType'
>): void => {
  const debounceKey =
    typeof payload === 'string'
      ? `update:requestBody:value-${contentType}`
      : undefined

  eventBus.emit(
    'operation:update:requestBody:value',
    {
      payload,
      contentType,
      meta: meta.value,
    },
    {
      debounceKey,
    },
  )
}

/** Handle request body value update */
const handleUpdateBodyFormValue = ({
  payload,
  contentType,
}: Pick<
  ApiReferenceEvents['operation:update:requestBody:formValue'],
  'payload' | 'contentType'
>): void => {
  const debounceKey = `update:requestBody:${contentType}-form-value`

  eventBus.emit(
    'operation:update:requestBody:formValue',
    {
      payload: payload.map((row) => unpackProxyObject(row, { depth: 1 })),
      contentType,
      meta: meta.value,
    },
    {
      debounceKey,
    },
  )
}

const labelRequestNameId = useId()
</script>
<template>
  <ViewLayoutSection :aria-label="`Request: ${operation.summary}`">
    <template #title>
      <div
        class="group pointer-events-none flex flex-1 items-center gap-1 lg:pr-24">
        <label
          v-if="layout !== 'modal'"
          class="pointer-events-auto absolute top-0 left-0 h-full w-full cursor-text opacity-0"
          :for="labelRequestNameId" />
        <input
          v-if="layout !== 'modal'"
          :id="labelRequestNameId"
          class="text-c-1 group-hover-input pointer-events-auto relative z-10 -ml-0.5 h-8 w-full rounded pl-1.25 has-[:focus-visible]:outline md:-ml-1.25"
          :placeholder="requestNamePlaceholder"
          :value="operation.summary"
          @input="handleSummaryUpdate" />
        <span
          v-else
          class="text-c-1 flex h-8 items-center">
          {{ operation.summary }}
        </span>
      </div>
      <SectionFilter
        v-model="selectedFilter"
        :filterIds="filterIds"
        :filters="filters" />
    </template>

    <div
      :id="filterIds.All"
      class="request-section-content custom-scroll relative flex flex-1 flex-col"
      :role="selectedFilter === 'All' ? 'tabpanel' : 'none'">
      <!-- Auth Selector -->
      <AuthSelector
        v-show="isSectionVisible('Auth') && !isAuthHidden"
        :id="filterIds.Auth"
        :environment
        :eventBus
        :meta="authMeta"
        :proxyUrl
        :securityRequirements
        :securitySchemes
        :selectedSecurity
        :selectedSecuritySchemes
        :server
        title="Authentication" />

      <!-- Variables (Path Parameters) -->
      <RequestParams
        v-show="isSectionVisible('Variables') && sections.path?.length"
        :id="filterIds.Variables"
        :environment
        :eventBus
        :exampleKey
        :rows="sections.path ?? []"
        :showAddRowPlaceholder="false"
        title="Variables"
        v-on="parameterHandlers.path" />

      <!-- Cookies -->
      <RequestParams
        v-show="isSectionVisible('Cookies')"
        :id="filterIds.Cookies"
        :environment
        :eventBus
        :exampleKey
        :rows="cookies ?? []"
        :showAddRowPlaceholder="true"
        title="Cookies"
        v-on="parameterHandlers.cookie" />

      <!-- Headers -->
      <RequestParams
        v-show="isSectionVisible('Headers')"
        :id="filterIds.Headers"
        :environment
        :eventBus
        :exampleKey
        :rows="headers ?? []"
        title="Headers"
        v-on="parameterHandlers.header" />

      <!-- Query Parameters -->
      <RequestParams
        v-show="isSectionVisible('Query')"
        :id="filterIds.Query"
        :environment
        :eventBus
        :exampleKey
        :rows="sections.query ?? []"
        title="Query Parameters"
        v-on="parameterHandlers.query" />

      <!-- Request Body -->
      <RequestBody
        v-show="isSectionVisible('Body') && canMethodHaveBody(method)"
        :id="filterIds.Body"
        :environment
        :exampleKey
        :requestBody="getResolvedRef(operation.requestBody)"
        title="Request Body"
        @update:contentType="handleUpdateContentType"
        @update:formValue="handleUpdateBodyFormValue"
        @update:value="handleUpdateBodyValue" />

      <!-- Inject request section plugin components -->
      <ScalarErrorBoundary
        v-for="(plugin, index) in plugins"
        :key="index">
        <component
          :is="plugin.components.request"
          v-if="plugin?.components?.request"
          :operation
          :selectedExample="exampleKey" />
      </ScalarErrorBoundary>

      <!-- Spacer -->
      <div class="flex grow" />
      <!-- Code Snippet -->
      <RequestCodeSnippet
        v-show="selectedFilter === 'All'"
        :clientOptions
        :eventBus
        :globalCookies="globalCookies"
        integration="client"
        :method
        :operation
        :path
        :securitySchemes="selectedSecuritySchemes"
        :selectedClient
        :selectedContentType="
          getResolvedRef(operation.requestBody)?.[
            'x-scalar-selected-content-type'
          ]?.[exampleKey]
        "
        :selectedServer="server ?? undefined" />
    </div>
  </ViewLayoutSection>
</template>
<style scoped>
.request-section-content {
  --scalar-border-width: 0.5px;
}
.request-section-content-filter {
  box-shadow: 0 -10px 0 10px var(--scalar-background-1);
}
.request-item:focus-within .request-meta-buttons {
  opacity: 1;
}
.group-hover-input {
  border-width: var(--scalar-border-width);
  border-color: transparent;
}
.group:hover .group-hover-input {
  background: color-mix(
    in srgb,
    var(--scalar-background-1),
    var(--scalar-background-2)
  );
  border-color: var(--scalar-border-color);
}
.group-hover-input:focus {
  background: transparent !important;
  border-color: var(--scalar-border-color) !important;
}
</style>
