<script lang="ts" setup>
import {
  ScalarSidebarGroup,
  ScalarSidebarGroupToggle,
  ScalarSidebarItem,
  ScalarSidebarSection,
} from '@scalar/components'
import {
  Draggable,
  type DraggingItem,
  type HoveredItem,
} from '@scalar/draggable'
import { ScalarIconFolder } from '@scalar/icons'
import type { TraversedEntry } from '@scalar/workspace-store/schemas/navigation'

import SidebarHttpBadge from './SidebarHttpBadge.vue'

export type Item =
  | TraversedEntry
  | { id: string; title: string; children: TraversedEntry[]; type: 'document' }

const { item, layout, isSelected, isExpanded } = defineProps<{
  item: Item
  layout: 'client' | 'reference'
  isSelected: (id: string) => boolean
  isExpanded: (id: string) => boolean
  options:
    | {
        operationTitleSource: 'path' | 'summary' | undefined
      }
    | undefined
}>()

const emits = defineEmits<{
  (e: 'selectItem', id: string): void
  (e: 'onDragEnd', draggingItem: DraggingItem, hoveredItem: HoveredItem): void
}>()

defineSlots<{
  aside?(props: { item: Item }): unknown
}>()

const hasChildren = (
  currentItem: Item,
): currentItem is Item & { children: TraversedEntry[] } => {
  return (
    'children' in currentItem &&
    Array.isArray(currentItem.children) &&
    currentItem.children.length > 0
  )
}

const isGroup = (
  currentItem: Item,
): currentItem is Item & { isGroup: true } => {
  return 'isGroup' in currentItem && currentItem.isGroup
}

/** Extract the path or title from a TraversedEntry */
const getPathOrTitle = (currentItem: Item): string => {
  if ('path' in currentItem) {
    // Insert zero-width space after every slash, to give line-break opportunity.
    return currentItem.path.replace(/\//g, '/\u200B')
  }
  return currentItem.title
}

const filterItems = (items: Item[]) => {
  if (layout === 'reference') {
    return items
  }

  // For client layout, filter to only show webhooks and operations
  return items.filter(
    (c) =>
      c.type === 'webhook' ||
      c.type === 'operation' ||
      c.type === 'example' ||
      c.type === 'tag',
  )
}

/**
 * Handle drag end event and bubble it up to parent.
 */
const handleDragEnd = (
  draggingItem: DraggingItem,
  hoveredItem: HoveredItem,
) => {
  emits('onDragEnd', draggingItem, hoveredItem)
}
</script>
<template>
  <Draggable
    :id="item.id"
    class="flex flex-1 flex-col wrap-break-word"
    :isDraggable="layout === 'client'"
    :parentIds="[]"
    @onDragEnd="handleDragEnd">
    <ScalarSidebarSection
      v-if="hasChildren(item) && isGroup(item)"
      @selectItem="() => emits('selectItem', item.id)">
      {{ item.title }}
      <template #items>
        <SidebarItem
          v-for="child in filterItems(item.children)"
          :key="child.id"
          :isExpanded="isExpanded"
          :isSelected="isSelected"
          :item="child"
          :layout="layout"
          :options="options"
          @onDragEnd="handleDragEnd"
          @selectItem="(id) => emits('selectItem', id)">
          <template #aside="slotProps">
            <slot
              v-bind="slotProps"
              name="aside" />
          </template>
        </SidebarItem>
      </template>
    </ScalarSidebarSection>
    <ScalarSidebarGroup
      v-else-if="
        hasChildren(item) &&
        ((layout === 'reference' &&
          !(item.type === 'operation' || item.type === 'webhook')) ||
          layout === 'client')
      "
      :active="isSelected(item.id)"
      :modelValue="isExpanded(item.id)"
      @update:modelValue="() => emits('selectItem', item.id)">
      <div class="group/entry flex min-w-0 flex-1 items-center">
        <div class="min-w-0 flex-1">{{ item.title }}</div>
        <slot
          :item="item"
          name="aside" />
      </div>
      <SidebarHttpBadge
        v-if="'method' in item"
        :active="isSelected(item.id)"
        class="min-w-9.75 justify-end text-right"
        :method="item.method"
        :webhook="item.type === 'webhook'" />
      <template
        v-if="item.type === 'document'"
        #icon="{ open }">
        <ScalarIconFolder
          class="text-c-3 block group-hover/group-button:hidden" />
        <ScalarSidebarGroupToggle
          class="text-c-3 hidden group-hover/group-button:block"
          :open="open" />
      </template>
      <template #items>
        <SidebarItem
          v-for="child in filterItems(item.children)"
          :key="child.id"
          :isExpanded="isExpanded"
          :isSelected="isSelected"
          :item="child"
          :layout="layout"
          :options="options"
          :parentIds="[]"
          @onDragEnd="handleDragEnd"
          @selectItem="(id) => emits('selectItem', id)">
          <template #aside="slotProps">
            <slot
              v-bind="slotProps"
              name="aside" />
          </template>
        </SidebarItem>
      </template>
    </ScalarSidebarGroup>
    <ScalarSidebarItem
      is="button"
      v-else
      class="text-left"
      :selected="isSelected(item.id)"
      @click="() => emits('selectItem', item.id)">
      <div class="group/entry flex min-w-0 flex-1 items-center">
        <div class="min-w-0 flex-1">
          <template v-if="options?.operationTitleSource === 'path'">
            {{ getPathOrTitle(item) }}
          </template>
          <template v-else>
            {{ item.title }}
          </template>
        </div>
        <slot
          :item="item"
          name="aside" />
      </div>
      <template
        v-if="'method' in item"
        #aside>
        <SidebarHttpBadge
          :active="isSelected(item.id)"
          class="min-w-9.75 justify-end text-right"
          :method="item.method"
          :webhook="item.type === 'webhook'" />
      </template>
    </ScalarSidebarItem>
  </Draggable>
</template>
